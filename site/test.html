<html>
  <head>
    <style>
      * {
        font-family: Verdana;
      }
      .spacer {
        flex: 1;
      }
      .board {
        display: flex;
        flex-direction: column;
        font-family: monospace;
        border: 1px solid #000;
      }
      .board-row {
        display: flex;
      }
      .square {
        height: 50px;
        width: 50px;
        border: 1px solid #000;
        display: flex;
        flex-direction: column;
      }
      .token-row {
        flex: 1;
        display: flex;
        flex-direction: row;
      }
      .token {
        flex: 1;
        text-align: center;
        font-size: 15pt;
      }
      .token.selected {
        text-shadow:
          -1px -1px 0 cyan,
          1px -1px 0 cyan,
          -1px  1px 0 cyan,
          1px  1px 0 cyan;
      }
      .bot0 {
        color: crimson;
      }
      .bot1 {
        color: royalblue;
      }
      .symbolgroup {
        margin: 1ex;
        padding: 1ex;
        border: 1px solid #000;
        border-radius: 5px;
      }
      .symbolgroup.selected {
        background: yellow;
      }
      .toggle {
        display: flex;
        flex-direction: row;
        margin: 1ex;
      }
      .toggle input {
        position: absolute !important;
        clip: rect(0, 0, 0, 0);
        overflow: hidden;
      }
      .toggle label {
        background-color: #ccc;
        color: #444;
        text-align: center;
        line-height: 1;
        padding: 8px 16px;
        margin-right: -1px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3), 0 1px rgba(255, 255, 255, 0.1);
        transition: all 0.1s ease-in-out;
      }
      .toggle input:checked + label {
        color: #eee;
        background: green;
        box-shadow: none;
      }
      .toggle input:checked + label.red {
        background: crimson;
      }
      .toggle input:checked + label.blue {
        background: royalblue;
      }
      .toggle label:first-of-type {
        border-radius: 5px 0 0 5px;
      }
      .toggle label:last-of-type {
        border-radius: 0 5px 5px 0;
      }
    </style>
  </head>
  <body>
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="./embindings.js"></script>
    <script type="text/babel">
      var levels = {
        "not": "../examples/not.lvl",
        "xor": "../examples/xor.lvl",
        "rainbow": "../examples/rainbow.lvl",
        "median": "../examples/median.lvl",
        "adder": "../examples/adder.lvl",
      };
      Module.onRuntimeInitialized = _ => {
        console.log("loaded");
      }
      var board;
      var level;
      var submission;
      function compute() {
        // level = document.getElementById("level").value;
        submission = document.getElementById("submission").value;
        board = Module.LoadBoard(level, submission);
        console.log(board.check_status());
        // board.run(100);
        // console.log(board.check_status());
      }
      function getFileFromServer(url, doneCallback) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            doneCallback(xhr.status == 200 ? xhr.responseText : null);
          }
        }
        xhr.open("GET", url, true);
        xhr.send();
      }
      function pickLevel() {
        var path = levels[document.getElementById("level_select").value];
        getFileFromServer(path, function(text) {
          if (text !== null) level = text;
        });
      }

      class Token extends React.Component {
        render() {
          return (
            <div onClick={() => {this.props.handler(this.props.y, this.props.x, this.props.symbolGroup, this.props.className);}} className={`token ${this.props.className} ${this.props.selectedSymbolGroup === this.props.symbolGroup ? "selected" : ""}`}>
              {(((this.props.symbolGroup || {}).state || {}).value || {})[this.props.index]}
            </div>
          );
        }
      }

      class Square extends React.Component {
        renderToken(props) {
          return (
            <Token handler={this.props.handler} selectedSymbolGroup={this.props.selectedSymbolGroup} y={this.props.y} x={this.props.x} index={0} {...props}/>
          );
        }

        render() {
          return (
            <div className="square">
              <div className="token-row">
                {this.renderToken({className:"unresolved", symbolGroup:this.props.unresolved, index:this.props.unresolved_index})}
                {this.renderToken({className:"bot0 direction", symbolGroup:this.props.direction[0]})}
                {this.renderToken({className:"bot1 direction", symbolGroup:this.props.direction[1]})}
              </div>
              <div className="token-row">
                {this.renderToken({className:"resolved", symbolGroup:this.props.resolved})}
                {this.renderToken({className:"bot0 operation", symbolGroup:this.props.operation[0]})}
                {this.renderToken({className:"bot1 operation", symbolGroup:this.props.operation[1]})}
              </div>
            </div>
          );
        }
      }

      class Board extends React.Component {
        renderSquare(props, y, x) {
          return (<Square key={y,x} handler={this.props.handler} selectedSymbolGroup={this.props.selectedSymbolGroup} y={y} x={x} {...props}/>);
        }

        render() {
          return (
            <div className="board">
              {this.props.squares.slice(0, this.props.m).map((row, y) =>
                <div key={y} className="board-row">
                  {row.slice(0, this.props.n).map((square, x) => this.renderSquare(square, y, x))}
                </div>
              )}
            </div>
          );
        }
      }

      class Game extends React.Component {
        constructor(props) {
          super(props);
          this.colors = ["RED", "BLUE"];
          this.symbolHandler = this.symbolHandler.bind(this);
          this.boardHandler = this.boardHandler.bind(this);
          this.changeSymbolOption = this.changeSymbolOption.bind(this);
          this.symbolTypeHandler = this.symbolTypeHandler.bind(this);
          this.botHandler = this.botHandler.bind(this);
          this.trash = this.trash.bind(this);
          this.state = {
            squares: Array.from({length: this.props.m}, e => Array.from({length: this.props.n}, e => ({
              unresolved: null,
              unresolved_index: null,
              resolved: null,
              direction: [null, null],
              operation: [null, null],
            }))),
            bot: 0,
            symbolType: "unresolved",
            selectedSymbolGroup: null,
            selectedSymbolGroupState: null,
            selectedOnBoard: false,
          };
        }

        renderSymbolGroup(type, props) {
          return (
            <SymbolGroup active={this.state.symbolType===type} handler={this.symbolHandler} selected={this.state.selectedSymbolGroup} {...props}/>
          );
        }

        render() {
          return (
            <div style={{display:"flex", flexDirection:"column", width:"min-content"}} className="game">
              <div style={{display:"flex"}} className="game-board">
                <Board handler={this.boardHandler} selectedSymbolGroup={this.state.selectedSymbolGroup} m={this.props.m} n={this.props.n} squares={this.state.squares}/>
              </div>
              <div style={{display:"flex", flexDirection:"column"}}>
                <div style={{display:"flex", flexDirection:"row", alignItems:"center"}}>
                  <Toggle handler={this.symbolTypeHandler} selected={this.state.symbolType} name="symbol-type" options={{unresolved:"Cells", instruction:"Instructions"}}/>
                  <Toggle handler={this.botHandler} selected={this.state.bot} name="bot" options={["Red", "Blue"]} colors={["red", "blue"]}/>
                  {this.state.selectedSymbolGroup && this.state.selectedOnBoard &&
                    <React.Fragment>
                      <div style={{flex:1}}></div>
                      <div onClick={this.trash}>TRASH</div>
                    </React.Fragment>
                  }
                </div>
                <div style={{display:"flex", flexDirection:"row"}}>
                  <div style={{flex:3, display:"flex", flexDirection:"row", flexWrap: "wrap"}}>
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "x", value: "x"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "+", value: "+"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "/", value: "/"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "\\", value: "\\"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "-", value: "-"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "|", value: "|"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "][", value: "][", multi:"horizontal"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "W\nM", value: "WM", multi:"vertical"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "<x", value: "<x", multi:"horizontal"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "^\nx", value: "^x", multi:"vertical"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "x>", value: "x>", multi:"horizontal"})}
                    {this.renderSymbolGroup("unresolved", {type: "unresolved", subtype: "x\nv", value: "xv", multi:"vertical"})}
                    {this.renderSymbolGroup("instruction", {type: "direction", subtype: "<", value: "<"})}
                    {this.renderSymbolGroup("instruction", {type: "direction", subtype: "v", value: "v"})}
                    {this.renderSymbolGroup("instruction", {type: "direction", subtype: ">", value: ">"})}
                    {this.renderSymbolGroup("instruction", {type: "direction", subtype: "^", value: "^"})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "START", value: "S"})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "NEXT", value: "n"})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "GRAB/DROP", options: {GRAB: "g", DROP: "d", SWAP: "w"}})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "LATCH/UNLATCH", options: {LATCH: "l", UNLATCH: "u", "TOGGLE LATCH": "t"}})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "REFRESH", value: "*"})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "SYNC", value: "s"})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "ROTATE", value: "r"})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "BRANCH(|/)", options: {"<": "<", "v": "v", ">": ">", "^": "^"}})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "BRANCH(-\)", options: {"<": "[", "v": "W", ">": "]", "^": "M"}})}
                    {this.renderSymbolGroup("instruction", {type: "operation", subtype: "POWER", options: {"TOGGLE POWER 1": "p", "TOGGLE POWER 2": "P"}})}
                  </div>
                  <div style={{flex:1, display:"flex", flexDirection:"column"}}>
                    <SymbolOptions changeOption={this.changeSymbolOption} {...this.state.selectedSymbolGroupState}/>
                  </div>
                </div>
              </div>
            </div>
          );
        }

        botHandler(value) { this.setState({bot: value}); }
        symbolTypeHandler(value) {
          this.setState((state, props) => {
            if (state.symbolType !== value) {
              if (state.selectedOnBoard) {
                return {symbolType: value};
              } else {
                return {symbolType: value, selectedSymbolGroup: null, selectedSymbolGroupState: null};
              }
            }
          });
        }

        boardHandler(y, x, symbolGroup, className) {
          if (symbolGroup && symbolGroup.state) {
            if (className.split(/\s+/).includes("resolved")) {
              this.setState({selectedSymbolGroup: null, selectedSymbolGroupState: null, selectedOnBoard: true});
            } else {
              this.setState({selectedSymbolGroup: symbolGroup, selectedSymbolGroupState: Object.assign({}, symbolGroup.props, symbolGroup.state), selectedOnBoard: true});
            }
          } else if (this.state.selectedOnBoard) {
            this.setState({selectedSymbolGroup: null, selectedSymbolGroupState: null, selectedOnBoard: true});
          } else {
            if (this.state.selectedSymbolGroup && this.state.selectedSymbolGroup.state) {
              // js doesn't have references...
              if (this.state.selectedSymbolGroup.props.type === "unresolved") {
                var current = this.state.squares[y][x].unresolved;
                if (this.state.selectedSymbolGroup.props.multi === "horizontal") {
                  if (x + 1 >= this.props.n) return;
                  var partner = this.state.squares[y][x + 1].unresolved;
                } else if (this.state.selectedSymbolGroup.props.multi === "vertical") {
                  if (y + 1 >= this.props.m) return;
                  var partner = this.state.squares[y + 1][x].unresolved;
                } else {
                  var partner = {state: false};
                }
              } else {
                var current = this.state.squares[y][x][this.state.selectedSymbolGroup.props.type][this.state.bot];
                var partner = {state: false};
              }
              if ((!current || !current.state) && (!partner || !partner.state)) {
                var symbolClone = {props: {...this.state.selectedSymbolGroup.props}, state: {...this.state.selectedSymbolGroup.state}};
                symbolClone.state.count = symbolClone.state.count + 1;
                symbolClone.setState = (func, callback) => {symbolClone.state = Object.assign(symbolClone.state, func(symbolClone.state, symbolClone.props)); callback()};
                var new_state = {squares: [...this.state.squares]}
                if (this.state.selectedSymbolGroup.props.type === "unresolved") {
                  new_state.squares[y][x].unresolved = symbolClone;
                  new_state.squares[y][x].unresolved_index = 0;
                  if (this.state.selectedSymbolGroup.props.multi === "horizontal") {
                    new_state.squares[y][x + 1].unresolved = symbolClone;
                    new_state.squares[y][x + 1].unresolved_index = 1;
                  } else if (this.state.selectedSymbolGroup.props.multi === "vertical") {
                    new_state.squares[y + 1][x].unresolved = symbolClone;
                    new_state.squares[y + 1][x].unresolved_index = 1;
                  }
                } else {
                  new_state.squares[y][x][this.state.selectedSymbolGroup.props.type][this.state.bot] = symbolClone;
                }
                new_state.selectedSymbolGroupState = Object.assign({}, symbolClone.props, symbolClone.state);
                this.setState(new_state);
              }
            }
          }
        }

        trash() {
          if (this.state.selectedSymbolGroup && this.state.selectedOnBoard) {
            this.state.selectedSymbolGroup.state = false;
            this.setState({selectedSymbolGroup: null, selectedSymbolGroupState: null, selectedOnBoard: false});
          }
        }

        symbolHandler(symbolGroup) {
          this.setState({selectedSymbolGroup: symbolGroup, selectedSymbolGroupState: Object.assign({}, symbolGroup.props, symbolGroup.state), selectedOnBoard: false});
        }

        changeSymbolOption(event) {
          let value = event.target.value;
          this.state.selectedSymbolGroup.setState((state, props) => ({
            selectedOption: value,
            value: props.options[value],
          }), () => {this.setState({selectedSymbolGroupState: Object.assign({}, this.state.selectedSymbolGroup.props, this.state.selectedSymbolGroup.state)})});
        };
      }

      class Toggle extends React.Component {
        render() {
          return (
            <div className="toggle">
              {Object.keys(this.props.options).map(option =>
                <React.Fragment key={`radio-${option}`}>
                  <input type="radio" id={`radio-${option}`} value={option} name={this.props.name}
                      // == to equate "1" with 1
                      checked={this.props.selected == option}
                      onChange={this.handle}
                  />
                  <label htmlFor={`radio-${option}`} className={(this.props.colors||{})[option]}>{this.props.options[option]}</label>
                </React.Fragment>
              )}
            </div>
          );
        }
        handle = event => this.props.handler(event.target.value);
      }

      class SymbolGroup extends React.Component {
        constructor(props) {
          super(props);
          // props: type, subtype, value, options
          this.state = {};
          this.state.count = 0;
          this.state.value = this.props.value;
          if (this.props.options !== undefined) {
            this.state.selectedOption = Object.keys(this.props.options)[0];
            this.state.value = this.props.options[this.state.selectedOption];
          }
        }
        render() {
          if (!this.props.active) return null;
          return (
            <div className={`symbolgroup ${this.props.selected === this ? "selected" : ""}`} style={{whiteSpace:"pre-line", alignItems:"bottom"}} onClick={this.pushThis}>{this.props.subtype}</div>
          );
        }
        pushThis = () => { this.props.handler(this); };
      }

      class SymbolOptions extends React.Component {
        render() {
          return (
            <div className="symbol-options">
              {Object.keys(this.props.options || []).map((option, i) =>
                <OptionItem key={i} option={option} {...this.props}/>
              )}
            </div>
          );
        }
      }

      class OptionItem extends React.Component {
        render() {
          return (
            <div style={{display:"flex", alignItems:"center"}} key={`radio-option-${this.props.option}`}>
              <input type="radio" id={`radio-${this.props.option}-${this.props.count}`} value={this.props.option} name={`radio-for-${this.props.subtype}-${this.props.count}`}
                  checked={this.props.selectedOption === this.props.option}
                  onChange={this.props.changeOption}
              />
              <label htmlFor={`radio-${this.props.option}-${this.props.count}`}>{this.props.option}</label>
            </div>
          );
        }
      }

      ReactDOM.render(
        <Game m={10} n={14}/>,
        document.getElementById('game')
      );
    </script>

    <div style="display:flex;">
      <div style="margin:1vw; display:flex; flex-direction:column;">
        <div>
          <label for="level_select">Choose level:</label>
          <select name="level_select" id="level_select" onchange="pickLevel()">
            <option value="not">not</option>
            <option value="xor">xor</option>
            <option value="rainbow">rainbow</option>
            <option value="median">median</option>
            <option value="adder">adder</option>
          </select>
        </div>
        <textarea name="submission" id="submission" rows=20 cols=40></textarea>
        <input type="button" value="Validate" onclick="compute();" />
      </div>
      <div style="margin:1vw;" id="game"></div>
    </div>
  </body>
</html>

<html>
  <head>
    <style>
      * {
        font-family: Verdana;
      }
      textarea {
        font-family: monospace;
      }
      .spacer {
        flex: 1;
      }
      .board {
        display: flex;
        flex-direction: column;
        font-family: monospace;
        border: 1px solid #000;
      }
      .board-row {
        display: flex;
      }
      .square {
        height: 50px;
        width: 50px;
        border: 1px solid #000;
        display: flex;
        flex-direction: column;
      }
      .token-row {
        flex: 1;
        display: flex;
        flex-direction: row;
      }
      .token {
        flex: 1;
        text-align: center;
        font-size: 15pt;
      }
      .token.selected {
        text-shadow:
          -1px -1px 0 cyan,
          1px -1px 0 cyan,
          -1px  1px 0 cyan,
          1px  1px 0 cyan;
      }
      .bot0-token {
        color: crimson;
      }
      .bot1-token {
        color: royalblue;
      }
      .bot0 {
        box-shadow: inset 3px 3px 5px crimson, inset -3px -3px 5px crimson;
      }
      .bot1 {
        box-shadow: inset 3px 3px 5px royalblue, inset -3px -3px 5px royalblue;
      }
      .bot0.bot1 {
        /* mix crimson and royalblue */
        box-shadow: inset 5px 5px 5px #8e3e8e, inset -5px -5px 5px  #8e3e8e;
      }
      .symbolgroup {
        margin: 1ex;
        padding: 1ex;
        border: 1px solid #000;
        border-radius: 5px;
      }
      .symbolgroup.selected {
        background: yellow;
      }
      .trash {
        font-size: 30px;
      }
      .trash:hover {
        text-shadow:
          -1px -1px 0 red,
          1px -1px 0 red,
          -1px  1px 0 red,
          1px  1px 0 red;
      }
      .untrespassable {
        background: gray;
      }
      .toggle {
        display: flex;
        flex-direction: row;
        margin: 1ex;
      }
      .toggle input {
        position: absolute !important;
        clip: rect(0, 0, 0, 0);
        overflow: hidden;
      }
      .toggle label {
        background-color: #ccc;
        color: #444;
        text-align: center;
        line-height: 1;
        padding: 8px 16px;
        margin-right: -1px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3), 0 1px rgba(255, 255, 255, 0.1);
        transition: all 0.1s ease-in-out;
      }
      .toggle input:checked + label {
        color: #eee;
        background: green;
        box-shadow: none;
      }
      .toggle input:checked + label.red {
        background: crimson;
      }
      .toggle input:checked + label.blue {
        background: royalblue;
      }
      .toggle label:first-of-type {
        border-radius: 5px 0 0 5px;
      }
      .toggle label:last-of-type {
        border-radius: 0 5px 5px 0;
      }
    </style>
  </head>
  <body>
    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="./embindings.js"></script>
    <script type="text/babel">
      var levels = {
        "not": "../examples/not.lvl",
        "xor": "../examples/xor.lvl",
        "rainbow": "../examples/rainbow.lvl",
        "median": "../examples/median.lvl",
        "adder": "../examples/adder.lvl",
      };
      Module.onRuntimeInitialized = _ => {
        ReactDOM.render(
          <Game m={10} n={14}/>,
          document.getElementById('game')
        );
        console.log("loaded");
      }
      var level_debug;
      var board_debug;
      var submission_debug;
      function compute() {
        // level_debug = document.getElementById("level").value;
        submission_debug = document.getElementById("submission").value;
        board_debug = Module.LoadBoard(level, submission_debug);
        console.log(board_debug.check_status());
        // board_debug.run(100);
        // console.log(board_debug.check_status());
      }
      function getFileFromServer(url, doneCallback) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            doneCallback(xhr.status == 200 ? xhr.responseText : null);
          }
        }
        xhr.open("GET", url, true);
        xhr.send();
      }

      class Token extends React.PureComponent {
        render() {
          var c = (((this.props.symbolGroup || {}).state || {}).value || {})[this.props.index];
          if (this.props.cellValue !== undefined) {
            if (!this.props.stopped || !c) c = this.props.cellValue && String.fromCharCode(this.props.cellValue);
          }
          return (
            <div onClick={() => {this.props.handler(this.props.y, this.props.x, this.props.symbolGroup, this.props.className);}} className={`token ${this.props.className} ${this.props.selectedSymbolGroup && this.props.selectedSymbolGroup === this.props.symbolGroup ? "selected" : ""}`}>
              {c}
            </div>
          );
        }
      }

      class Square extends React.PureComponent {
        renderToken(props) {
          return (
            <Token handler={this.props.handler} selectedSymbolGroup={this.props.selectedSymbolGroup} selectedSymbolValue={this.props.selectedSymbolValue} y={this.props.y} x={this.props.x} index={0} stopped={this.props.stopped} {...props}/>
          );
        }

        render() {
          var classNames = [];
          classNames.push("square");
          if (this.props.bot0) classNames.push("bot0");
          if (this.props.bot1) classNames.push("bot1");
          if (this.props.trespassable !== undefined) classNames.push(this.props.trespassable ? "trespassable" : "untrespassable");
          classNames.push();
          return (
            <div className={classNames.join(" ")}>
              <div className="token-row">
                {this.renderToken({className:"unresolved", cellValue:(this.props.cell && this.props.cell.unresolved()), symbolGroup:this.props.unresolved, index:this.props.unresolved_index})}
                {this.renderToken({className:"bot0-token direction", symbolGroup:this.props.direction[0]})}
                {this.renderToken({className:"bot1-token direction", symbolGroup:this.props.direction[1]})}
              </div>
              <div className="token-row">
                {this.renderToken({className:"resolved", cellValue:(this.props.cell && this.props.cell.resolved())})}
                {this.renderToken({className:"bot0-token operation", symbolGroup:this.props.operation[0]})}
                {this.renderToken({className:"bot1-token operation", symbolGroup:this.props.operation[1]})}
              </div>
            </div>
          );
        }
      }

      class Board extends React.PureComponent {
        renderSquare(props) {
          return (<Square
            key={props.y,props.x}
            handler={this.props.handler}
            validBoard={this.props.validBoard}
            selectedSymbolGroup={this.props.selectedSymbolGroup}
            selectedSymbolValue={this.props.selectedSymbolValue}
            stopped={this.props.stopped}
            {...props}
          />);
        }

        render() {
          return (
            <div className="board">
              {this.props.squares.slice(0, this.props.m).map((row, y) =>
                <div key={y} className="board-row">
                  {row.slice(0, this.props.n).map((square, x) => this.renderSquare(Object.assign(
                  {
                    y: y,
                    x: x,
                    cell: ((this.props.cells || {})[y] || {})[x],
                    trespassable: ((this.props.trespassable || {})[y] || {})[x],
                    bot0: ((this.props.bots[0] || {}).location || {}).valid && this.props.bots[0].location.y === y && this.props.bots[0].location.x === x,
                    bot1: ((this.props.bots[1] || {}).location || {}).valid && this.props.bots[1].location.y === y && this.props.bots[1].location.x === x,
                  },
                  square)))}
                </div>
              )}
            </div>
          );
        }
      }

      class Game extends React.Component {
        constructor(props) {
          super(props);
          this.symbolHandler = this.symbolHandler.bind(this);
          this.boardHandler = this.boardHandler.bind(this);
          this.changeSymbolOption = this.changeSymbolOption.bind(this);
          this.symbolTypeHandler = this.symbolTypeHandler.bind(this);
          this.botHandler = this.botHandler.bind(this);
          this.simHandler = this.simHandler.bind(this);
          this.resetBoard = this.resetBoard.bind(this);
          this.resetCells = this.resetCells.bind(this);
          this.trash = this.trash.bind(this);
          this.setLevelHandler = this.setLevelHandler.bind(this);
          this.setBoardHandler = this.setBoardHandler.bind(this);
          this.loadSubmission = this.loadSubmission.bind(this);
          this.setTextarea = this.setTextarea.bind(this);
          this.state = {
            levelName: Object.keys(levels)[0],
            levelData: null,
            squares: Array.from({length: this.props.m}, e => Array.from({length: this.props.n}, e => ({
              unresolved: null,
              unresolved_index: null,
              resolved: null,
              direction: [null, null],
              operation: [null, null],
            }))),
            textarea: "",
            // backend
            board: null, // Emscripten pointer
            cells: [], // 2D array of Emscripten pointers
            trespassable: [], // 2D array of bools
            bots: [null, null], // converted to javascript objects
            level_grid: [], // array of chars
            inputs: [],
            outputs: [],
            outputColors: [],
            step: 0,
            validBoard: false, // set from reset_and_validate()
            // simulation
            simState: "stop",
            simTimeout: null,
            // selection
            symbolType: "unresolved",
            bot: 0,
            selectedSymbolGroup: null,
            selectedSymbolGroupState: null,
            selectedOnBoard: false,
          };
        }

        componentDidMount() {
          this.setLevelHandler({target: {value: this.state.levelName}});
        }

        makeSubmission(squares, m, n) {
          var join = func => squares.slice(0, m).map(row => row.slice(0, n).map(square => {
            let [symbolGroup, index] = func(square);
            return (((symbolGroup || {}).state || {}).value || {})[index] || "_";
          }).join("")).join("\n");
          var unresolved = join(square => [square.unresolved, square.unresolved_index])
          var direction0 = join(square => [square.direction[0], 0])
          var operation0 = join(square => [square.operation[0], 0])
          var direction1 = join(square => [square.direction[1], 0])
          var operation1 = join(square => [square.operation[1], 0])
          return [unresolved, direction0, operation0, direction1, operation1].join("\n\n");
        }

        renderSymbolGroup(type, props) {
          return (
            <SymbolGroup key={props.subtype} active={this.state.symbolType===type} handler={this.symbolHandler} selected={this.state.selectedSymbolGroup} {...props}/>
          );
        }

        symbolTypesUnresolved = [
          {type: "unresolved", subtype: "x", value: "x"},
          {type: "unresolved", subtype: "+", value: "+"},
          {type: "unresolved", subtype: "/", value: "/"},
          {type: "unresolved", subtype: "\\", value: "\\"},
          {type: "unresolved", subtype: "-", value: "-"},
          {type: "unresolved", subtype: "|", value: "|"},
          {type: "unresolved", subtype: "][", value: "][", multi:"horizontal"},
          {type: "unresolved", subtype: "W\nM", value: "WM", multi:"vertical"},
          {type: "unresolved", subtype: "<x", value: "<x", multi:"horizontal"},
          {type: "unresolved", subtype: "^\nx", value: "^x", multi:"vertical"},
          {type: "unresolved", subtype: "x>", value: "x>", multi:"horizontal"},
          {type: "unresolved", subtype: "x\nv", value: "xv", multi:"vertical"},
        ];
        symbolTypesDirection = [
          {type: "direction", subtype: "<", value: "<"},
          {type: "direction", subtype: "v", value: "v"},
          {type: "direction", subtype: ">", value: ">"},
          {type: "direction", subtype: "^", value: "^"},
        ];
        symbolTypesOperation = [
          {type: "operation", subtype: "START", value: "S"},
          {type: "operation", subtype: "NEXT", value: "n"},
          {type: "operation", subtype: "GRAB/DROP", options: {GRAB: "g", DROP: "d", SWAP: "w"}},
          {type: "operation", subtype: "LATCH/UNLATCH", options: {LATCH: "l", UNLATCH: "u", "TOGGLE LATCH": "t"}},
          {type: "operation", subtype: "REFRESH", value: "*"},
          {type: "operation", subtype: "SYNC", value: "s"},
          {type: "operation", subtype: "ROTATE", value: "r"},
          {type: "operation", subtype: "BRANCH(|/)", options: {"<": "<", "v": "v", ">": ">", "^": "^"}},
          {type: "operation", subtype: "BRANCH(-\)", options: {"<": "[", "v": "W", ">": "]", "^": "M"}},
          {type: "operation", subtype: "POWER", options: {"TOGGLE POWER 1": "p", "TOGGLE POWER 2": "P"}},
        ];

        loadSubmission(submission) {
          this.setState((state, props) => {
            var newState = {squares: state.squares.map(row => row.map(square => {
              let d = {};
              for (key in square) {
                if (Array.isArray(square[key])) d[key] = square[key].map(_ => null);
                else d[key] = null;
              }
              return d;
            }))};
            var get = (type, c) => {
              if ("._ ".includes(c)) return [null];
              var symbols;
              if (type === "unresolved") symbols = this.symbolTypesUnresolved;
              else if (type === "direction") symbols = this.symbolTypesDirection;
              else if (type === "operation") symbols = this.symbolTypesOperation;
              else return [];
              for (let symbolType of symbols) {
                if ((symbolType.value || "").includes(c)) {
                  let newSymbol = {props: symbolType, state: {value: symbolType.value}}
                  newSymbol.setState = (func, callback) => {newSymbol.state = Object.assign(newSymbol.state, func(newSymbol.state, newSymbol.props)); callback()};
                  if (symbolType.multi === "horizontal") return [newSymbol, 0, 1];
                  else if (symbolType.multi === "vertical") return [newSymbol, 1, 0];
                  else return [newSymbol];
                } else if (Object.values(symbolType.options || {}).includes(c)) {
                  let newSymbol = {props: symbolType, state: {value: c}}
                  newSymbol.setState = (func, callback) => {newSymbol.state = Object.assign(newSymbol.state, func(newSymbol.state, newSymbol.props)); callback()};
                  return [newSymbol];
                }
              }
              return [];
            }
            var parse = (type, bot, lines) => {
              if (lines.length !== state.board.m) return false;
              let grid = Array.from({length: this.state.board.m}).map(row => Array(this.state.board.n).fill(null));
              let indices = Array.from({length: this.state.board.m}).map(row => Array(this.state.board.n).fill(null));
              for (let y=0; y<grid.length; ++y) {
                if (lines[y].length !== state.board.n) return false;
                for (let x=0; x<grid[y].length; ++x) if (!grid[y][x]) {
                  let [value, dy, dx] = get(type, lines[y][x]);
                  if (value === undefined) return false;
                  grid[y][x] = value;
                  indices[y][x] = 0;
                  if (dy || dx) {
                    grid[y+dy][x+dx] = value;
                    indices[y+dy][x+dx] = 1;
                  }
                }
              }
              for (let y=0; y<grid.length; ++y) for (let x=0; x<grid[y].length; ++x) {
                if (type === "unresolved") {
                  newState.squares[y][x].unresolved = grid[y][x];
                  newState.squares[y][x].unresolved_index = indices[y][x];
                } else {
                  newState.squares[y][x][type][bot] = grid[y][x];
                }
              }
              return true;
            };
            var lines = submission.split(/(?:\r?\n)+/);
            var valid = true;
            valid &= parse("unresolved", null, lines.slice(0, state.board.m));
            valid &= parse("direction", 0, lines.slice(state.board.m, 2*state.board.m));
            valid &= parse("operation", 0, lines.slice(2*state.board.m, 3*state.board.m));
            valid &= parse("direction", 1, lines.slice(3*state.board.m, 4*state.board.m));
            valid &= parse("operation", 1, lines.slice(4*state.board.m, 5*state.board.m));
            if (!valid) {
              console.log("Could not parse input");
              return null;
            }
            return newState;
          },
          this.resetBoard);
        }

        render() {
          return (
            <div style={{display:"flex"}}>
              <div style={{margin:"1vw", display:"flex", flexDirection:"column"}}>
                <div>
                  <label htmlFor="level_select">Choose level:</label>
                  <select name="level_select" id="level_select" value={this.state.levelName} onChange={this.setLevelHandler}>
                    {Object.keys(levels).map(levelName => <option key={levelName} value={levelName}>{levelName}</option>)}
                  </select>
                </div>
                <textarea name="submission" id="submission" value={this.state.textarea} rows={20} cols={40} onChange={this.setTextarea}/>
                <input type="button" value="Validate" onClick={this.setBoardHandler}/>
              </div>
              <div style={{display:"flex", flexDirection:"column", width:"min-content"}} className="game">
                <div style={{display:"flex"}} className="game-board">
                  <Board
                    handler={this.boardHandler}
                    selectedSymbolGroup={this.state.selectedSymbolGroup}
                    selectedSymbolValue={((this.state.selectedSymbolGroup || {}).state || {}).value}
                    validBoard={this.state.validBoard}
                    stopped={this.state.simState==="stop"}
                    m={this.props.m}
                    n={this.props.n}
                    squares={this.state.squares}
                    cells={this.state.cells}
                    trespassable={this.state.trespassable}
                    bots={this.state.bots}
                  />
                </div>
                <div style={{display:"flex", flexDirection:"column"}}>
                  <div style={{display:"flex", flexDirection:"row", alignItems:"center"}}>
                    <Toggle handler={this.symbolTypeHandler} selected={this.state.symbolType} name="symbol-type" options={{unresolved:"Cells", instruction:"Instructions"}}/>
                    <Toggle handler={this.botHandler} selected={this.state.bot} name="bot" options={["Red", "Blue"]} colors={["red", "blue"]}/>
                    <Toggle handler={this.simHandler} selected={this.state.simState} name="sim" options={{stop:"⏹", pause:"⏸", step:"⧐", play:"▶", fast:"⏩"}}/>
                    {this.state.selectedSymbolGroup && this.state.selectedOnBoard &&
                      <React.Fragment>
                        <div style={{flex:1}}></div>
                        <div className="trash" onClick={this.trash}>🗑</div>
                      </React.Fragment>
                    }
                  </div>
                  <div style={{display:"flex", flexDirection:"row"}}>
                    <div style={{flex:3, display:"flex", flexDirection:"row", flexWrap: "wrap"}}>
                      {this.symbolTypesUnresolved.map(props => this.renderSymbolGroup("unresolved", props))}
                      {this.symbolTypesDirection.map(props => this.renderSymbolGroup("instruction", props))}
                      {this.symbolTypesOperation.map(props => this.renderSymbolGroup("instruction", props))}
                    </div>
                    <div style={{flex:1, display:"flex", flexDirection:"column"}}>
                      <SymbolOptions changeOption={this.changeSymbolOption} {...this.state.selectedSymbolGroupState}/>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        }

        botHandler(value) { this.setState({bot: value}); }
        symbolTypeHandler(value) {
          this.setState((state, props) => {
            if (state.symbolType !== value) {
              if (state.selectedOnBoard) {
                return {symbolType: value};
              } else {
                return {symbolType: value, selectedSymbolGroup: null, selectedSymbolGroupState: null};
              }
            }
          });
        }
        simHandler(value) {
          const INITIAL_DELAY = 200; // ms
          const PLAY_INTERVAL = 1000; // ms
          const FAST_INTERVAL = 100; // ms
          var needsToResetBoard = false;
          this.setState((state, props) => {
            if (state.simState === value) return null;
            var newState = {simState: value, selectedSymbolGroup: null, selectedSymbolGroupState: null};
            clearTimeout(this.state.simTimeout);
            var makeRepeat = interval => {
              var self = this;
              return setTimeout(
                function callOnce() {
                  self.move();
                  self.setState((state, props) => { clearTimeout(state.simTimeout); return {simTimeout: setTimeout(callOnce, interval)}; }); },
                INITIAL_DELAY);
            }
            if (value === "step") newState.simTimeout = setTimeout(() => { this.move(); this.simHandler("pause"); }, INITIAL_DELAY);
            else if (value === "play") newState.simTimeout = makeRepeat(PLAY_INTERVAL);
            else if (value === "fast") newState.simTimeout = makeRepeat(FAST_INTERVAL);
            else if (value === "stop") {
              needsToResetBoard = true;
            }
            return newState;
          },
          () => {
            if(needsToResetBoard) {
              this.setState(
                (state, props) => ({validBoard: !state.board.reset_and_validate()}),
                this.resetCells);
            }
          });
        }

        boardHandler(y, x, symbolGroup, className) {
          if (this.state.simState !== "stop") return;
          if (symbolGroup && symbolGroup.state) {
            if (className.split(/\s+/).includes("resolved")) {
              this.setState({selectedSymbolGroup: null, selectedSymbolGroupState: null, selectedOnBoard: true});
            } else {
              this.setState({selectedSymbolGroup: symbolGroup, selectedSymbolGroupState: Object.assign({}, symbolGroup.props, symbolGroup.state), selectedOnBoard: true});
            }
          } else if (this.state.selectedOnBoard) {
            this.setState({selectedSymbolGroup: null, selectedSymbolGroupState: null, selectedOnBoard: true});
          } else {
            if (this.state.selectedSymbolGroup && this.state.selectedSymbolGroup.state) {
              // js doesn't have references...
              if (this.state.selectedSymbolGroup.props.type === "unresolved") {
                var current = this.state.squares[y][x].unresolved;
                if (this.state.selectedSymbolGroup.props.multi === "horizontal") {
                  if (x + 1 >= this.props.n) return;
                  var partner = this.state.squares[y][x + 1].unresolved;
                } else if (this.state.selectedSymbolGroup.props.multi === "vertical") {
                  if (y + 1 >= this.props.m) return;
                  var partner = this.state.squares[y + 1][x].unresolved;
                } else {
                  var partner = {state: false};
                }
              } else {
                var current = this.state.squares[y][x][this.state.selectedSymbolGroup.props.type][this.state.bot];
                var partner = {state: false};
              }
              if ((!current || !current.state) && (!partner || !partner.state)) {
                var symbolClone = {props: {...this.state.selectedSymbolGroup.props}, state: {...this.state.selectedSymbolGroup.state}};
                symbolClone.setState = (func, callback) => {symbolClone.state = Object.assign(symbolClone.state, func(symbolClone.state, symbolClone.props)); callback()};
                var newState = {squares: this.state.squares.map(row => row.map(square => ({...square})))};
                if (this.state.selectedSymbolGroup.props.type === "unresolved") {
                  newState.squares[y][x].unresolved = symbolClone;
                  newState.squares[y][x].unresolved_index = 0;
                  if (this.state.selectedSymbolGroup.props.multi === "horizontal") {
                    newState.squares[y][x + 1].unresolved = symbolClone;
                    newState.squares[y][x + 1].unresolved_index = 1;
                  } else if (this.state.selectedSymbolGroup.props.multi === "vertical") {
                    newState.squares[y + 1][x].unresolved = symbolClone;
                    newState.squares[y + 1][x].unresolved_index = 1;
                  }
                } else {
                  newState.squares[y][x][this.state.selectedSymbolGroup.props.type][this.state.bot] = symbolClone;
                }
                newState.selectedSymbolGroupState = Object.assign({}, symbolClone.props, symbolClone.state);
                this.setState(newState, this.resetBoard);
              }
            }
          }
        }

        resetBoard() {
          this.setState((state, props) => {
            var newState = {};
            if (state.board) state.board.delete();
            var submission = this.makeSubmission(state.squares, props.m, props.n);
            newState.board = Module.LoadBoard(state.levelData, submission);
            newState.validBoard = newState.board.check_status() !== Module.Status.INVALID;
            var trespassable = newState.board.get_trespassable();
            newState.trespassable = Array.from({length: newState.board.m}).map((row, y) => Array.from({length: newState.board.n}).map((cell, x) => {
              return trespassable.at(y, x);
            }));
            trespassable.delete();
            var boardLevel = newState.board.get_level();
            newState.level_grid = Array.from({length: newState.board.m}).map((row, y) => Array.from({length: newState.board.n}).map((cell, x) => {
              return boardLevel.at(y, x);
            }));
            boardLevel.delete();
            return newState;
          },
          this.resetCells);
        }

        resetCells() {
          this.setState((state, props) => {
            var newState = {};
            state.cells.forEach(row => row.forEach(cell => {
              if (cell) cell.delete();
            }));
            var cells = state.board.get_cells();
            newState.cells = Array.from({length: state.board.m}).map((row, y) => Array.from({length: state.board.n}).map((cell, x) => {
              return cells.at(y, x);
            }));
            cells.delete();
            var bots = state.board.get_bots();
            newState.bots = Array.from({length: bots.size()}).map((bot, k) => bots.get(k));
            bots.delete();
            if (state.board.check_status() === Module.Status.INVALID) console.log(state.board.get_error());
            return newState;
          });
        }

        move() {
          this.state.board.move();
          this.resetCells();
        }

        trash() {
          if (this.state.selectedSymbolGroup && this.state.selectedOnBoard) {
            this.state.selectedSymbolGroup.state = false;
            this.setState({selectedSymbolGroup: null, selectedSymbolGroupState: null, selectedOnBoard: false}, this.resetBoard);
          }
        }

        setTextarea(event) {
          this.setState({textarea: event.target.value});
        }

        setLevelHandler(event) {
          var value = event.target.value;
          if (this.state.levelData == null || value !== this.state.levelName) {
            var path = levels[value];
            getFileFromServer(path, (text) => {
              if (text) {
                this.setState({
                  levelName: value,
                  levelData: text,
                },
                this.resetBoard);
              }
            });
          }
        }

        setBoardHandler(event) {
          this.loadSubmission(this.state.textarea);
        }

        symbolHandler(symbolGroup) {
          if (this.state.simState !== "stop") return;
          this.setState({selectedSymbolGroup: symbolGroup, selectedSymbolGroupState: Object.assign({}, symbolGroup.props, symbolGroup.state), selectedOnBoard: false});
        }

        changeSymbolOption(event) {
          let value = event.target.value;
          this.state.selectedSymbolGroup.setState((state, props) => ({
            value: props.options[value],
          }), () => {this.setState({selectedSymbolGroupState: Object.assign({}, this.state.selectedSymbolGroup.props, this.state.selectedSymbolGroup.state)})});
        };
      }

      class Toggle extends React.PureComponent {
        render() {
          return (
            <div className="toggle">
              {Object.keys(this.props.options).map(option =>
                <React.Fragment key={`radio-${option}`}>
                  <input type="radio" id={`radio-${option}`} value={option} name={this.props.name}
                      // == to equate "1" with 1
                      checked={this.props.selected == option}
                      onChange={this.handle}
                  />
                  <label htmlFor={`radio-${option}`} className={(this.props.colors||{})[option]}>{this.props.options[option]}</label>
                </React.Fragment>
              )}
            </div>
          );
        }
        handle = event => this.props.handler(event.target.value);
      }

      class SymbolGroup extends React.PureComponent {
        constructor(props) {
          super(props);
          // props: type, subtype, value, options
          this.state = {};
          this.state.value = this.props.value;
          if (this.props.options !== undefined) {
            let option = Object.keys(this.props.options)[0];
            this.state.value = this.props.options[option];
          }
        }
        render() {
          if (!this.props.active) return null;
          return (
            <div className={`symbolgroup ${this.props.selected === this ? "selected" : ""}`} style={{whiteSpace:"pre-line", alignItems:"bottom"}} onClick={this.pushThis}>{this.props.subtype}</div>
          );
        }
        pushThis = () => { this.props.handler(this); };
      }

      class SymbolOptions extends React.PureComponent {
        render() {
          return (
            <div className="symbol-options">
              {Object.keys(this.props.options || []).map((option, i) =>
                <OptionItem key={i} option={option} {...this.props}/>
              )}
            </div>
          );
        }
      }

      class OptionItem extends React.PureComponent {
        render() {
          return (
            <div style={{display:"flex", alignItems:"center"}} key={`radio-option-${this.props.option}`}>
              <input type="radio" id={`radio-${this.props.option}`} value={this.props.option} name={`radio-for-${this.props.subtype}`}
                  checked={this.props.value === this.props.options[this.props.option]}
                  onChange={this.props.changeOption}
              />
              <label htmlFor={`radio-${this.props.option}`}>{this.props.option}</label>
            </div>
          );
        }
      }
    </script>

    <div style="margin:1vw;" id="game"></div>
  </body>
</html>
